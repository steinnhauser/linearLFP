""" Study which takes a single cell from the network simulated, inserts
multiple compartmental potential recordings and views how these evolve in the
various network conditions.
"""

import numpy as np
import scipy.stats as st
from mpi4py import MPI
import neuron
import json
import os, sys
import h5py
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.gridspec import GridSpec
from mpl_toolkits.mplot3d import Axes3D
import LFPy
from LFPy import NetworkCell, Network, Synapse, RecExtElectrode
from LFPy.inputgenerators import get_activation_times_from_distribution

import utils.plotter as pf
import utils.misc as mf
import utils.tester as tf

jfile = open("./init/setup.json", "r", encoding="utf-8")
jdict = json.load(jfile)
jfile.close()

COMM = MPI.COMM_WORLD
SIZE = COMM.Get_size()
RANK = COMM.Get_rank()

GLOBALSEED = 1234
np.random.seed(GLOBALSEED + RANK)

####### Read in the data #######
READPATH = './true_sim/'        # path for read files
OUTPUTPATH = './fake_sim_isyn/'      # path for write files

# Read in some HDF files generated by example_network
f1 = h5py.File(READPATH + 'cell_positions_and_rotations.h5', "r")
f2 = h5py.File(READPATH + 'synapse_positions.h5', "r")

headers1 = ['gid', 'x', 'y', 'z', 'x_rot', 'y_rot','z_rot']
f1E = pd.DataFrame(np.array(f1.get('E')), columns=headers1)
f1I = pd.DataFrame(np.array(f1.get('I')), columns=headers1)
df1 = pd.concat({'E':f1E, 'I':f1I})

headers2 = ['gid', 'idx', 'weight', 'delay', 'pre_gid']
f2E_E = pd.DataFrame(np.array(f2.get('E:E')), columns = headers2)
f2E_I = pd.DataFrame(np.array(f2.get('E:I')), columns = headers2)
f2I_E = pd.DataFrame(np.array(f2.get('I:E')), columns = headers2)
f2I_I = pd.DataFrame(np.array(f2.get('I:I')), columns = headers2)
df2 = pd.concat({'E:E':f2E_E,'E:I':f2E_I,'I:E':f2I_E,'I:I':f2I_I})

f1.close(); f2.close()

# Read in the spikes saved from previous simulations
sph5 = h5py.File(READPATH + "savedSpikes.h5", "r")
spikeTimes = []; spikeGid = []
for pop in jdict["population_names"]:
    group = sph5.get(pop)
    spikeTimes += group.get("spikeTimes")[:].tolist()
    spikeGid += group.get("spikeGid")[:].tolist()
sph5.close()

# Generate [GID, spike time] list
numGids = int(max(spikeGid))+1  # should equal total number of cells
gid_spikes = [[] for _ in range(numGids)]
for time, gid in zip(spikeTimes, spikeGid):
    gid_spikes[int(gid)].append(time)

# Read in the 'outsideSpikes.h5' file generated by 'example_network'.
sph5 = h5py.File(READPATH + "outsideSpikes.h5", "r")
spike_trains = \
[ # create a list where spike_trains[gid] returns a list of all firing times
    [ # the first element of each of these lists is the compartment index.
        firing_rates[:] for firing_rates in sph5.get(f'{cell_no}').values()
    ] for cell_no in range(numGids)]
sph5.close()

# neuron.load_mechanisms('L5bPCmodelsEH/mod/')

cellParameters = dict(
    morphology='./init/BallAndStick_active.hoc',    # use hh for generation.
    templatefile='./init/BallAndStickTemplate.hoc',
    templatename='BallAndStickTemplate',
    templateargs=None,
    delete_sections=False,
    dt = 2**jdict['dt'],
    tstart = 0,
    tstop = jdict['tstop'],
)
# cellParameters = {
#     'morphology'    : 'L5bPCmodelsEH/morphologies/cell1.asc',
#     'templatefile'  : ['L5bPCmodelsEH/models/L5PCbiophys3.hoc',
#                        'L5bPCmodelsEH/models/L5PCtemplate.hoc'],
#     'templatename'  : 'L5PCtemplate',
#     'templateargs'  : 'L5bPCmodelsEH/morphologies/cell1.asc',
#     'passive' : False,
#     'nsegs_method' : None,
#     'dt' : 2**jdict['dt'],
#     'tstart' : 0,
#     'tstop' : jdict['tstop'],
#     'v_init' : -60,
#     'celsius': 34,
#     'pt3d' : True,
#     'delete_sections' : False,
# }

cell = LFPy.TemplateCell(**cellParameters)
# exit()

synapseParameters = dict(
    E = dict(tau1=0.2, tau2=1.8, e=0.),
    I = dict(tau1=0.1, tau2=9.0, e=-80.)
)

# Calculate the scaling factors for the current-synapse weights here.
scales = dict(
    E = -(jdict["isyn_v_approx"] - synapseParameters['E']['e']),
    I = -(jdict["isyn_v_approx"] - synapseParameters['I']['e'])
)

# Add outside synapses. pick a random GID to copy.
gid = 43; nidx = 64
currentCell = df2[df2['gid']==gid]
rows, columns = currentCell.shape

# Set up loop for all synapses connected to current cell.
for _, row in currentCell.iterrows():

    delay  = row['delay']
    weight = row['weight']
    pregid = int(row['pre_gid'])
    idxnum = int(row['idx'])

    """ Need to generalize the synapse parameters argument to be
    dependent on the pre_gid variable. This is done by acknowlegding
    the name attribute of the 'iterrows' Pandas method. The name
    should include something like 'E:E' or 'I:E', and the synaptic
    parameters should be dependent on the pre-synaptic term (i.e.
    'E' for 'E:I' and 'I' for 'I:E'). """
    name = row.name[0]
    pre_type = name[0]

    # Set up the synapse object to emulate this neural connection
    syn = Synapse(cell=cell,
        idx=idxnum,
        syntype='Exp2ISyn',
        weight=weight*scales[pre_type],
        **synapseParameters[pre_type])

    """ Set spike times according to pre-synaptic firing rates.
    Make sure to include the characteristic synaptic delay. """
    spike_time_list = [i + delay for i in gid_spikes[pregid]]
    syn.set_spike_times(np.array(spike_time_list))

# add 'inside' synapses as well.
for i in range(nidx):
    listobj = spike_trains[gid][i]
    syn = Synapse(cell=cell,
                idx=int(listobj[0]),
                syntype='Exp2ISyn',
                weight=0.002*scales['E'],
                **dict(tau1=0.2, tau2=1.8, e=0.))
    syn.set_spike_times(np.array(listobj[1:]))

cell.simulate(rec_vmem=True)
# cell_cond_somav_rel = cell.somav

numpoints_sims = int(jdict['tstop']/(2**jdict['dt'])) + 1
time_axis_sims = np.linspace(0, jdict['tstop'], numpoints_sims)


fig, ax = plt.subplots(1, 1) #nr nc
elec_coords = np.linspace(1000., -200., 13)
vals = []
for ch_no, z in enumerate(elec_coords):
    idx = cell.get_closest_idx(z=z)
    from_when = np.where(time_axis_sims > 200)[0][0]
    vals.append(cell.vmem[idx][from_when:])

flierprops = dict(marker='.', markerfacecolor='r', markersize=1,
    markeredgecolor='r')
ax.boxplot(vals[::-1], vert=0, labels=range(1, 14), flierprops=flierprops)
ax.set_yticks(range(13, 0, -1))
ax.set_ylabel("Channel no.")
ax.set_xlabel("Membrane Potential [mV]")
ax.grid(axis='x', linestyle='--', alpha=0.6)

par1 = ax.twinx()
par1.plot(np.ones(len(elec_coords)), elec_coords, alpha=0)
par1.set_ylabel("z-coordinate [Âµm]")

fig.savefig("./figures/channel_boxplots.pdf", bbox_inches='tight')
print("./figures/channel_boxplots.pdf saved.")
plt.close(fig)

# look at VMEM
# print(np.array(VMEM).shape)
fig, ax = plt.subplots(1, 1)
id = ((time_axis_sims > 1500) & (time_axis_sims < 2000))
im = ax.imshow(np.array(cell.vmem)[:, id], interpolation='none')#[:, 1500:2000])
plt.colorbar(im)
ax.axis(ax.axis('tight'))
fig.savefig("./figures/segment_potentials.pdf")
print("./figures/segment_potentials.pdf saved.")
plt.close(fig)
